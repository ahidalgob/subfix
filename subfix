#!/usr/bin/env python3
import re
import sys, os
import argparse
import subprocess, tempfile

import credentials

import json
from watson_developer_cloud import SpeechToTextV1

def to_ms(h, m, s, ms):
    ms = ms[:3]
    while len(ms) < 3:
        ms = ms+'0'
    return int(ms) + int(s)*1000 + int(m)*60*1000 + int(h)*60*60*1000

def to_hmsms(tot, mss=','):
    def fix_len(s, l):
        while len(s) < l:
            s = '0'+s
        return s
    ms = str(tot%1000)
    tot = tot//1000
    s = str(tot%60)
    tot = tot//60
    m = str(tot%60)
    h = str(tot//60)
    ms = fix_len(ms, 3)
    s = fix_len(s, 2)
    m = fix_len(m, 2)
    h = fix_len(h, 2)
    return h+':'+m+':'+s+mss+ms

########### Returns a function that d
def shift(d):
    def internal_shift(match):
        subN, h1, m1, s1, ms1, h2, m2, s2, ms2, txt = \
            match.group('subN', 'h1', 'm1', 's1', 'ms1', \
                            'h2', 'm2', 's2', 'ms2', 'txt')
        if subN is None:
            subN = ''
        else:
            subN = subN + '\n'
        ret = subN + to_hmsms(to_ms(h1,m1,s1,ms1)+d) + ' --> ' \
                + to_hmsms(to_ms(h2,m2,s2,ms2)+d) + '\n' + txt
        return ret
    return internal_shift

subtitle_regex = re.compile(r"""
    ((?P<subN>\d+)\n)?
    (?P<first_time>(?P<h1>\d+):
    (?P<m1>\d+):
    (?P<s1>\d+),
    (?P<ms1>\d+))
    \s+ --> \s+
    (?P<h2>\d+):
    (?P<m2>\d+):
    (?P<s2>\d+),
    (?P<ms2>\d+)\n
    (?P<txt>.*? (?=\n*((\d+\n)?\d+:\d+:\d+,\d+ \s+ --> \s+ \d+:\d+:\d+,\d+)|\Z) )
    """, re.VERBOSE | re.MULTILINE | re.DOTALL)

time_regex = re.compile(r"""
    (?P<h1>\d+):
    (?P<m1>\d+):
    (?P<s1>\d+),
    (?P<ms1>\d+)
    """, re.VERBOSE | re.MULTILINE)


def simple_sync(all_matches, tmp_file):
    ########### GET THE SUBTITLE TO SYNC
    print('Look for the number of the entry you want to use to sync and then press \'q\'')
    input('(Press enter to continue)')

    tmp_file.flush()
    subprocess.run(['less', tmp_file.name])
    tmp_file.close()


    selected_match = None
    while selected_match is None:
        try:
            i = int(input('Entry number: '))-1
            assert(0 <= i <= len(all_matches))
            selected_match = all_matches[i]
        except KeyboardInterrupt:
            sys.exit(0)
        except:
            print('Invalid entry number.')
    ############################################


    ########### GET THE DESIRED TIME
    print("\nInsert the desired time for:\n   "
            +selected_match.group('txt').replace('\n',' '))
    print("\n(Currently at time "+ selected_match.group('first_time') +")")
    print("Please insert the desired time in the following format:\n\
    hours:minutes:seconds,milliseconds")

    desired = None
    while desired is None:
        desired = time_regex.match(input('Desired time: '))
        if desired is None:
            print('Invalid format, YOU CAN DO IT!.')
    ############################################


    hi, mi, si, msi = selected_match.group('h1', 'm1', 's1', 'ms1')
    hf, mf, sf, msf = desired.group('h1', 'm1', 's1', 'ms1')
    return to_ms(hf, mf, sf, msf) - to_ms(hi, mi, si, msi)


#######################################################
########### Amazing Scan
#######################################################
def get_transcription(movie_filename, start_time):
    # TO DO: GET THE BEST FORMAT/QUALITY FOR THE RIPPED AUDIO
    # TO DO: GET THE TMP FILE WORKING
    # TO DO: STUDY ABOUT THE STRUCTURE OF THE TRANSCRIPTION AND
    #        CONSTRUCT AN EASY TO HANDLE CONTAINER FOR IT

    print('Getting audio.')
    with open('audio.ogg','w') as fp:  # TESTING
    # with tempfile.NamedTemporaryFile(suffix='.ogg') as fp:
        subprocess.run(['yes | ffmpeg -i \"' + movie_filename +'\"'
            +' -vn -ss ' + to_hmsms(start_time, '.')
            + ' -t ' + to_hmsms(20*1000 -2, '.') + ' \"'+ fp.name + '\"'],  ### CHANGEEEEEEE 30
            stdout=open(os.devnull, "w"), stderr=subprocess.STDOUT, 
            shell=True)

    speech_to_text = SpeechToTextV1(
        username=credentials.USERNAME,
        password=credentials.PASSWORD,
        x_watson_learning_opt_out=False
    )

    # with open(join(dirname(__file__), '../resources/speech.wav'),
    #           'rb') as audio_file:
    with open('audio.ogg', 'rb') as audio_file: # TESTING
        print('Getting transcription.')
        transcription = speech_to_text.recognize(
            audio_file, content_type='audio/ogg', timestamps=True,
            word_confidence=True, model='en-US_NarrowbandModel')
        transcription = transcription['results']
        print(json.dumps(transcription, indent=2))
        for i in range(len(transcription)):
            print(transcription[i]['alternatives'][0]['transcript'])

def amazing_sync(all_matches, movie_filename):
    # Check if movie file name makes sense
    # Determine the audio interval we want to rip from the video
    get_transcription(movie_filename, 10*(60*1000))
    # Get best match
    print('TO DO')
    return 0



########### MAIN
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Subtitles syncer.')

    parser.add_argument('srt_file', help='The srt file to sync.')
    parser.add_argument('movie_file', nargs='?',
        help='The movie file that will be used to sync the srt file.')

    args = parser.parse_args()
    filename, movie_filename = args.srt_file, args.movie_file

    try:
        with open(filename, 'r') as myfile:
            subtitles_text = myfile.read()
    except:
        sys.exit("Error: the srt file doesn't exists or couldn't be opened D:\n")

    ########### Parsing srt file
    matches_iterator = subtitle_regex.finditer(subtitles_text)
    # tmp_file is used to get the more/less behavior
    tmp_file = open(tempfile.mkstemp()[1], 'w')
    all_matches = []
    i = 1
    for match in matches_iterator:
        print(i, ': ', match.group('txt').replace('\n',' '), 
                '\n', sep=' ', file=tmp_file)
        all_matches.append(match)
        i += 1

    if i==1:
        sys.exit("Error: the file isn't a valid str file D:\n")
    ############################################

    print('\nNote that the srt file will be OVERWRITTEN!')

    if movie_filename is None:
        dif = simple_sync(all_matches, tmp_file)
    else:
        dif = amazing_sync(all_matches, movie_filename)

    subtitles_text = subtitle_regex.sub(shift(dif), subtitles_text)

    with open(filename, 'w') as myfile:
        myfile.write(subtitles_text)