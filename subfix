#!/usr/bin/env python3
import re
import sys, os
import argparse
import subprocess, tempfile

import magic

import time

import credentials

import json
from watson_developer_cloud import SpeechToTextV1

MAX_SHIFT = 20000000000 * 60 * 1000
INTERVAL_LENGTH = 60*1000 -2

def to_ms(h, m, s, ms):
    ms = ms[:3]
    while len(ms) < 3:
        ms = ms+'0'
    return int(ms) + int(s)*1000 + int(m)*60*1000 + int(h)*60*60*1000

def to_hmsms(tot, ms_separator=','):
    def fix_len(s, l):
        while len(s) < l:
            s = '0'+s
        return s
    ms = str(tot%1000)
    tot = tot//1000
    s = str(tot%60)
    tot = tot//60
    m = str(tot%60)
    h = str(tot//60)
    ms = fix_len(ms, 3)
    s = fix_len(s, 2)
    m = fix_len(m, 2)
    h = fix_len(h, 2)
    return h+':'+m+':'+s+ms_separator+ms

########### Returns a function that shifts d milliseconds the 
# given matched subtitles.
def shift(d):
    def internal_shift(match):
        subN, h1, m1, s1, ms1, h2, m2, s2, ms2, txt = \
            match.group('subN', 'h1', 'm1', 's1', 'ms1', \
                            'h2', 'm2', 's2', 'ms2', 'txt')
        if subN is None:
            subN = ''
        else:
            subN = subN + '\n'
        ret = subN + to_hmsms(to_ms(h1,m1,s1,ms1)+d) + ' --> ' \
                + to_hmsms(to_ms(h2,m2,s2,ms2)+d) + '\n' + txt
        return ret
    return internal_shift

subtitle_regex = re.compile(r"""
    ((?P<subN>\d+)\n)?
    (?P<first_time>(?P<h1>\d+):
    (?P<m1>\d+):
    (?P<s1>\d+),
    (?P<ms1>\d+))
    \s+ --> \s+
    (?P<h2>\d+):
    (?P<m2>\d+):
    (?P<s2>\d+),
    (?P<ms2>\d+)\n
    (?P<txt>.*? (?=\n*((\d+\n)?\d+:\d+:\d+,\d+ \s+ --> \s+ \d+:\d+:\d+,\d+)|\Z))
    """, re.VERBOSE | re.MULTILINE | re.DOTALL)

time_regex = re.compile(r"""
    (?P<h1>\d+):
    (?P<m1>\d+):
    (?P<s1>\d+),
    (?P<ms1>\d+)
    """, re.VERBOSE | re.MULTILINE)


########### Simple Sync
# Asks for a subtitle frame to use as a sync point and then asks for the
# desired time for such frame.
# Returns the desired shift
def simple_sync(all_matches):
    # tmp_file is used to get the more/less behavior
    tmp_file = open(tempfile.mkstemp()[1], 'w')

    for i,match in enumerate(all_matches):
        print(i+1, ': ', match.group('txt').replace('\n',' '), 
                '\n', sep=' ', file=tmp_file)

    ########### GET THE SUBTITLE TO SYNC
    print('Look for the number of the subtitle frame you want to use to',
        'sync and then press \'q\'')
    input('(Press enter to continue)')

    tmp_file.flush()
    subprocess.run(['less', tmp_file.name])
    tmp_file.close()

    selected_match = None
    while selected_match is None:
        try:
            i = int(input('Frame number: '))-1
            assert(0 <= i < len(all_matches))
            selected_match = all_matches[i]
        except KeyboardInterrupt:
            sys.exit(0)
        except:
            print('Invalid frame number.')
    ############################################


    ########### GET THE DESIRED TIME
    print("\nInsert the desired time for:\n   "
            +selected_match.group('txt').replace('\n',' '))
    print("\n(Currently at time "+ selected_match.group('first_time') +")")
    print("Please insert the desired time in the following format:\n\
    hours:minutes:seconds,milliseconds")

    desired = None
    while desired is None:
        desired = time_regex.match(input('Desired time: '))
        if desired is None:
            print('Invalid format, YOU CAN DO IT!.')
    ############################################

    hi, mi, si, msi = selected_match.group('h1', 'm1', 's1', 'ms1')
    hf, mf, sf, msf = desired.group('h1', 'm1', 's1', 'ms1')
    return to_ms(hf, mf, sf, msf) - to_ms(hi, mi, si, msi)


#######################################################
########### Amazing Scan
#######################################################
def get_transcription(movie_filename, start_time):
    # TO DO: GET THE BEST FORMAT/QUALITY FOR THE RIPPED AUDIO
    # TO DO: MAKE MULTIPLE CONCURRENT TRANSCRIPTION TO SPEED UP THE BOTTLE NECK.
    audio_format = 'ogg'

    ########### Rips audio from video
    print('Getting audio.')
    tmp_audio_file = tempfile.NamedTemporaryFile(suffix='.'+audio_format)
    subprocess.run(['yes | ffmpeg -i \"' + movie_filename +'\"'
        +' -vn -ss ' + to_hmsms(start_time, '.')
        + ' -t ' + to_hmsms(INTERVAL_LENGTH, '.') + ' \"'+ tmp_audio_file.name + '\"'], 
        stdout=open(os.devnull, "w"), stderr=subprocess.STDOUT, 
        shell=True)
    ############################################

    speech_to_text = SpeechToTextV1(
        username=credentials.USERNAME,
        password=credentials.PASSWORD,
        x_watson_learning_opt_out=False
    )

    with open(tmp_audio_file.name, 'rb') as audio_file: # TESTING
        print('Getting transcription (chatting with watson).')
        transcription = speech_to_text.recognize(
            audio_file,
            content_type='audio/'+ audio_format,
            timestamps=True,
            word_confidence=True,
            model='en-US_NarrowbandModel',
            # model='en-US_BroadbandModel',
            # word_alternatives_threshold=0.3,
            # keywords={"math"}, keywords_threshold=0.4,
            # max_alternatives=5
            )

    tmp_audio_file.close()

    transcription = transcription['results']
    words = []  # word, start, middle, confidence
    for prt in transcription:
        bst = prt['alternatives'][0]
        for i in range(len(bst['timestamps'])):
            words.append({'word':bst['timestamps'][i][0].lower(),
                        'start':int(bst['timestamps'][i][1]*1000)+start_time,
                        'middle':int(bst['timestamps'][i][2]*1000)+start_time,
                        'confidence':bst['word_confidence'][i][1]})
    return words

def get_best(frames, trans_words, with_BS=True):
    # gets score of the match betweed 
    #   the words of frame f from word fw to the end
    #   and the next ntw words from tw

    memo, memo_s = {}, set()

    def get_frame_score(f, fw, tw, ntw):
        if fw == len(frames[f]['words']) and ntw==0:
            return 0
        if (f, fw, tw, ntw) in memo:
            return memo[(f, fw, tw, ntw)]
        ret = 0
        if fw!=len(frames[f]['words']):
            ret = max(ret, get_frame_score(f, fw+1, tw, ntw))
        if ntw !=0:
            ret = max(ret,  get_frame_score(f, fw, tw+1, ntw-1))
        if fw!=len(frames[f]['words']) and ntw !=0 and \
                    frames[f]['words'][fw] == trans_words[tw]['word']:
            ret = max(ret, get_frame_score(f, fw+1, tw+1, ntw-1) + \
                        1+trans_words[tw]['confidence'])
        memo[(f,fw,tw,ntw)] = ret
        return ret

    def get_score(f, tw, ntw):
        return get_frame_score(f, 0, tw, ntw)

    # s = shift: final-initial times of the frames
    def get_score_s(s):
        total_score = 0
        memo_s.add(s//100)

        i, j = 0, 0
        while i<len(frames) and j<len(trans_words):
            if frames[i]['end'] + s < trans_words[j]['middle']:
                lo, hi = i, len(frames) -1
                while lo < hi:
                    mi = (lo+hi+1)//2
                    start = frames[mi]['start'] + s
                    if start > trans_words[j]['middle']:
                        hi = mi-1
                    else:
                        lo = mi
                i = lo

            start = frames[i]['start'] + s
            end = frames[i]['end'] + s

            while j<len(trans_words) and trans_words[j]['middle'] < start:
                total_score -= trans_words[j]['confidence']
                j += 1
            if j<len(trans_words) and trans_words[j]['middle'] <= end:
                left = j
                while j<len(trans_words) and \
                        start <= trans_words[j]['middle'] <= end:
                    j += 1
                total_score += get_score(i, left, j-left)
            i += 1
        return total_score

    score = -1
    ans = 0
    for i,fr in enumerate(frames):
        for j,tw in enumerate(trans_words):
            s = tw['start'] - fr['start']
            if s//100 not in memo_s:
                nscore = get_score_s(s)
                if nscore > score:
                    score = nscore
                    ans = s

    return ans

def amazing_sync(all_matches, movie_filename):
    # TO DO: Determine the audio interval we want to rip from the video

    video_ok = True
    try:
        if 'video' not in magic.from_file(movie_filename, mime=True):
            video_ok = False
    except:
        exit('Error: The movie file doesn\'t exists or cannot be opened D:')

    if not video_ok:
        exit('Error: The movie file is not a video file D:')


    start_time = 10*(60*1000) # minute 10, TESTING
    trans_words = get_transcription(movie_filename, start_time)
    frames = []
    for match in all_matches:
        h1, m1, s1, ms1, h2, m2, s2, ms2, txt = \
            match.group('h1', 'm1', 's1', 'ms1', \
                        'h2', 'm2', 's2', 'ms2', 'txt')
        start, end = to_ms(h1, m1, s1, ms1), to_ms(h2, m2, s2, ms2)
        if end < start_time-MAX_SHIFT \
            or start > start_time + INTERVAL_LENGTH + MAX_SHIFT:
            continue
        frames.append({'start': start,
                        'end': end,
                        'words': re.sub('[!?,.â™ª]','',txt.lower()).split()})

    print('Magic happening.')

    # start_time = time.time()
    # get_best(frames, trans_words)
    # print("--- %s seconds ---" % (time.time() - start_time))

    return get_best(frames, trans_words)

########### MAIN
if __name__ == '__main__':
    # TO DO: Better help and instructions.
    ########### Parsing arguments
    parser = argparse.ArgumentParser(description='Subtitles syncer.')

    parser.add_argument('srt_file', help='The srt file to sync.')
    parser.add_argument('movie_file', nargs='?',
        help='The movie file that will be used to sync the srt file.')

    args = parser.parse_args()
    filename, movie_filename = args.srt_file, args.movie_file

    try:
        with open(filename, 'r') as myfile:
            subtitles_text = myfile.read()
    except:
        sys.exit("Error: the srt file doesn't exists or couldn't be opened D:\n")
    ############################################

    ########### Parsing srt file
    matches_iterator = subtitle_regex.finditer(subtitles_text)
    
    all_matches = []
    for match in matches_iterator:
        all_matches.append(match)

    if len(all_matches)==0:
        sys.exit("Error: the file isn't a valid str file D:\n")
    ############################################

    if movie_filename is None:
        dif = simple_sync(all_matches)
    else:
        dif = amazing_sync(all_matches, movie_filename)

    subtitles_text = subtitle_regex.sub(shift(dif), subtitles_text)

    confirm = None
    while confirm is None:
        print('The srt file will be OVERWRITTEN. [Y/n]')
        confirm = input()
        if confirm == 'Y':
            pass
        elif confirm == 'n':
            print('Canceled.')
            sys.exit(0)
        else:
            print('Invalid option')
            confirm = None
    with open(filename, 'w') as myfile:
        myfile.write(subtitles_text)
    print('Done :)')